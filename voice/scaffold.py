import os
import re

# =========================
# BASE OUTPUT DIRECTORY
# =========================
BASE_DIR = r"C:\Users\Ridhv\Desktop\websites\aiass\voice"
os.makedirs(BASE_DIR, exist_ok=True)

# ===============================
# INPUT: project tree
# ===============================
TREE = """
voice-keyboard/
│
├── main.py                     # Entry point (glue / event loop)
│
├── config/
│   ├── settings.json           # Global settings (limits, modes, flags)
│   └── keys.json               # Key maps, shortcuts
│
├── speech/
│   └── stt.py                  # Speech-to-text (mic → text)
│
├── intent/
│   ├── schema.py               # Intent JSON schema
│   ├── rule_router.py          # Rule-based intent router
│   ├── ai_router.py            # G4F AI intent router
│   ├── moderation.py           # Safety + eligibility checks
│   └── learner.py              # Learning & rule persistence
│
├── brain/
│   ├── keyboard_brain.py       # Intent → execution
│   └── state.py                # Mode & context state
│
├── os_actions/
│   ├── keyboard_utils.py       # Low-level key injection
│   ├── os_actions.py           # Open apps, websites, etc.
│   └── browser.py              # Browser helpers (search, tabs)
│
├── data/
│   ├── learned_rules.json      # Auto-learned rule patterns
│   └── logs.jsonl              # Shadow logs (append-only)
│
├── utils/
│   ├── normalizer.py           # Text cleanup & normalization
│   ├── logger.py               # Central logging
│   └── validators.py           # Schema & safety validation
│
├── tests/
│   ├── test_rules.py           # Rule router tests
│   ├── test_ai_router.py       # AI router tests
│   └── test_keyboard.py        # Execution tests (mocked)
│
├── requirements.txt            # Python dependencies
└── README.md                   # Project overview & usage               
"""

# ===============================
# PARSE TREE INTO RELATIVE PATHS
# ===============================
def parse_tree(tree_text):
    lines = tree_text.strip().splitlines()
    stack = []
    paths = []

    print("[DEBUG] Starting tree parsing")

    for line in lines:
        if not line.strip():
            continue

        # Count depth using box characters
        depth = line.count("│")

        # Extract clean name
        name = re.sub(r"[│├└─]+", "", line).strip()
        name = name.split("#")[0].strip()

        if not name:
            continue

        # Adjust stack
        stack = stack[:depth]
        stack.append(name.rstrip("/"))

        relative_path = os.path.join(*stack)
        paths.append(relative_path)

        print(f"[DEBUG] Parsed: {relative_path}")

    return paths

# ===============================
# CREATE STRUCTURE IN BASE_DIR
# ===============================
def create_structure(paths):
    print("\n[DEBUG] Creating folders & files")

    for rel_path in paths:
        abs_path = os.path.join(BASE_DIR, rel_path)

        # File vs folder detection
        if "." in os.path.basename(rel_path):
            folder = os.path.dirname(abs_path)
            os.makedirs(folder, exist_ok=True)

            if not os.path.exists(abs_path):
                with open(abs_path, "w") as f:
                    f.write("# Auto-generated by scaffold.py\n")
                print(f"[FILE] {abs_path}")
            else:
                print(f"[SKIP] {abs_path} already exists")
        else:
            os.makedirs(abs_path, exist_ok=True)
            print(f"[FOLDER] {abs_path}")

# ===============================
# RUN
# ===============================
if __name__ == "__main__":
    print("[START] Scaffolding project structure")
    paths = parse_tree(TREE)
    create_structure(paths)
    print("\n[DONE] Project structure created successfully")
